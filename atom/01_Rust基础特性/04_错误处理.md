# é”™è¯¯å¤„ç†

## ã€30å­—æ ¸å¿ƒã€‘

**é”™è¯¯å¤„ç†æ˜¯ Rust ç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œé€šè¿‡ Result/Option å®ç°ç¼–è¯‘æ—¶å¼ºåˆ¶çš„é”™è¯¯å¤„ç†ï¼Œripgrep ä¾æ­¤ä¼˜é›…å¤„ç† IO å’Œæ­£åˆ™ç¼–è¯‘é”™è¯¯ã€‚**

---

## ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### é”™è¯¯å¤„ç†çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**é”™è¯¯ = ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­çš„å¼‚å¸¸æƒ…å†µ**

**é”™è¯¯å¤„ç† = é¢„æœŸå¹¶å¤„ç†è¿™äº›å¼‚å¸¸æƒ…å†µçš„æœºåˆ¶**

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

#### 2. ä¸ºä»€ä¹ˆéœ€è¦é”™è¯¯å¤„ç†ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šå¦‚ä½•è®©ç¨‹åºåœ¨é¢å¯¹å¼‚å¸¸æƒ…å†µæ—¶ä¸å´©æºƒï¼ŒåŒæ—¶ä¿æŒä»£ç å¯è¯»æ€§å’Œç±»å‹å®‰å…¨ï¼Ÿ**

ä¼ ç»Ÿè¯­è¨€çš„å›°å¢ƒï¼š

| æ–¹æ¡ˆ | é—®é¢˜ |
|-----|------|
| è¿”å›é”™è¯¯ç ï¼ˆCï¼‰ | å®¹æ˜“å¿½ç•¥ï¼Œç±»å‹ä¸å®‰å…¨ï¼Œé”™è¯¯ä¿¡æ¯ä¸¢å¤± |
| å¼‚å¸¸æœºåˆ¶ï¼ˆJava/Pythonï¼‰ | éšå¼æ§åˆ¶æµï¼Œéš¾ä»¥æ¨ç†ï¼Œæ€§èƒ½å¼€é”€ |
| ç©ºå€¼ï¼ˆnullï¼‰ | "åäº¿ç¾å…ƒé”™è¯¯"ï¼Œè¿è¡Œæ—¶æ‰çˆ†ç‚¸ |

Rust çš„ç­”æ¡ˆæ˜¯ï¼š**ç±»å‹ç³»ç»Ÿå¼ºåˆ¶çš„é”™è¯¯å¤„ç†**

- ç¼–è¯‘ï¿½ï¿½ï¿½å¼ºåˆ¶å¤„ç†æ¯ä¸ªå¯èƒ½çš„é”™è¯¯
- é›¶è¿è¡Œæ—¶å¼€é”€ï¼ˆæ— å¼‚å¸¸è¡¨ï¼‰
- é”™è¯¯è·¯å¾„åœ¨ä»£ç ä¸­æ˜¾å¼å¯è§

#### 3. é”™è¯¯å¤„ç†çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šç¼–è¯‘æ—¶ä¿è¯ï¼ˆä¸èƒ½å¿½ç•¥é”™è¯¯ï¼‰
```rust
// ç¼–è¯‘å™¨å¼ºåˆ¶ï¼šå¿…é¡»å¤„ç† Result
let file = File::open("config.txt");  // è¿”å› Result<File, io::Error>
// file.read_to_string(&mut buf);  // âŒ ç¼–è¯‘é”™è¯¯ï¼file æ˜¯ Resultï¼Œä¸æ˜¯ File

// å¿…é¡»æ˜¾å¼å¤„ç†
let file = File::open("config.txt")?;  // âœ… ä¼ æ’­é”™è¯¯
// æˆ–
let file = match File::open("config.txt") {
    Ok(f) => f,
    Err(e) => return Err(e.into()),
};
```

##### ä»·å€¼2ï¼šé›¶æˆæœ¬æŠ½è±¡ï¼ˆæ— è¿è¡Œæ—¶å¼‚å¸¸å¼€é”€ï¼‰
```rust
// Result/Option åªæ˜¯æ™®é€šæšä¸¾ï¼Œæ²¡æœ‰å¼‚å¸¸è¡¨å¼€é”€
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// ? æ“ä½œç¬¦ç¼–è¯‘ä¸ºç®€å•çš„æ¨¡å¼åŒ¹é…
// æ²¡æœ‰æ ˆå±•å¼€ã€å¼‚å¸¸æ•è·ç­‰è¿è¡Œæ—¶æœºåˆ¶
```

##### ä»·å€¼3ï¼šæ¸…æ™°çš„æ§åˆ¶æµï¼ˆé”™è¯¯ä¼ æ’­å¯è§ï¼‰
```rust
// æ¯ä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œéƒ½æ˜¾å¼æ ‡è®°
fn process_config() -> Result<Config, Error> {
    let content = fs::read_to_string("config.toml")?;  // å¯èƒ½å¤±è´¥ç‚¹ 1
    let config: Config = toml::from_str(&content)?;    // å¯èƒ½å¤±è´¥ç‚¹ 2
    validate(&config)?;                                 // å¯èƒ½å¤±è´¥ç‚¹ 3
    Ok(config)
}
// ä»£ç é˜…è¯»è€…ä¸€çœ¼å°±èƒ½çœ‹åˆ°å“ªäº›æ“ä½œå¯èƒ½å¤±è´¥
```

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼ ripgrep çš„è®¾è®¡

**æ¨ç†é“¾ï¼š**
```
1. ripgrep éœ€è¦æ‰“å¼€ç”¨æˆ·æŒ‡å®šçš„æ–‡ä»¶
   â†“
2. æ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨ã€æ— æƒé™ã€è¢«å ç”¨
   â†“
3. æ­£åˆ™è¡¨è¾¾å¼å¯èƒ½è¯­æ³•é”™è¯¯
   â†“
4. éœ€è¦å¤„ç†è¿™äº›é”™è¯¯è€Œä¸æ˜¯å´©æºƒ
   â†“
5. Result<T, E> å¼ºåˆ¶å¤„ç†è¿™äº›æƒ…å†µ
   â†“
6. ? æ“ä½œç¬¦è®©é”™è¯¯å‘ä¸Šä¼ æ’­
   â†“
7. è‡ªå®šä¹‰é”™è¯¯ç±»å‹ç»Ÿä¸€ä¸åŒæ¥æºçš„é”™è¯¯
   â†“
8. ç»“æœï¼šç”¨æˆ·çœ‹åˆ°å‹å¥½çš„é”™è¯¯ä¿¡æ¯ï¼Œç¨‹åºä¼˜é›…é€€å‡º
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**é”™è¯¯å¤„ç†è®© Rust åœ¨ç¼–è¯‘æœŸå°±å¼ºåˆ¶å¤„ç†å¯èƒ½çš„å¤±è´¥æƒ…å†µï¼Œé€šè¿‡ Result/Option å®ç°é›¶æˆæœ¬çš„ç±»å‹å®‰å…¨é”™è¯¯ä¼ æ’­ã€‚**

---

## ã€æ ¸å¿ƒæ¦‚å¿µã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šResult<T, E> ç±»å‹ ğŸ¯

**Result æ˜¯è¡¨ç¤º"æˆåŠŸæˆ–å¤±è´¥"çš„æšä¸¾ï¼ŒæˆåŠŸæ—¶åŒ…å«å€¼ Tï¼Œå¤±è´¥æ—¶åŒ…å«é”™è¯¯ E**

```rust
// Result çš„å®šä¹‰
enum Result<T, E> {
    Ok(T),    // æˆåŠŸï¼ŒåŒ…å«å€¼
    Err(E),   // å¤±è´¥ï¼ŒåŒ…å«é”™è¯¯
}

// å®é™…ä½¿ç”¨
fn read_file(path: &str) -> Result<String, std::io::Error> {
    std::fs::read_to_string(path)
}

fn main() {
    match read_file("config.txt") {
        Ok(content) => println!("å†…å®¹: {}", content),
        Err(e) => println!("é”™è¯¯: {}", e),
    }
}
```

**Result å¼ºåˆ¶è°ƒç”¨è€…å¤„ç†ä¸¤ç§æƒ…å†µï¼Œä¸å¯èƒ½"å¿˜è®°"æ£€æŸ¥é”™è¯¯ã€‚**

**å¸¸ç”¨æ–¹æ³•é€ŸæŸ¥è¡¨ï¼š**

| æ–¹æ³• | ä½œç”¨ | é€‚ç”¨åœºæ™¯ |
|-----|------|---------|
| `unwrap()` | è·å–å€¼æˆ– panic | æµ‹è¯•ä»£ç ï¼Œç¡®ä¿¡ä¸ä¼šå¤±è´¥ |
| `expect(msg)` | è·å–å€¼æˆ– panic å¹¶æ˜¾ç¤ºæ¶ˆæ¯ | ä¸åº”å¤±è´¥çš„æ–­è¨€ |
| `unwrap_or(default)` | è·å–å€¼æˆ–ä½¿ç”¨é»˜è®¤å€¼ | æœ‰åˆç†é»˜è®¤å€¼æ—¶ |
| `unwrap_or_else(f)` | è·å–å€¼æˆ–è°ƒç”¨é—˜æ•° | é»˜è®¤å€¼éœ€è¦è®¡ç®—æ—¶ |
| `map(f)` | è½¬æ¢æˆåŠŸå€¼ | é“¾å¼å¤„ç†æˆåŠŸæƒ…å†µ |
| `map_err(f)` | è½¬æ¢é”™è¯¯å€¼ | é”™è¯¯ç±»å‹è½¬æ¢ |
| `and_then(f)` | é“¾å¼ Result æ“ä½œ | å¤šæ­¥å¯èƒ½å¤±è´¥çš„æ“ä½œ |
| `ok()` | Result â†’ Option | å¿½ç•¥é”™è¯¯è¯¦æƒ… |
| `?` | ä¼ æ’­é”™è¯¯æˆ–è§£åŒ…å€¼ | å‡½æ•°å†…éƒ¨é”™è¯¯å¤„ç† |

**åœ¨ ripgrep æºç ä¸­çš„åº”ç”¨ï¼š**
- æ–‡ä»¶æ‰“å¼€ï¼š`File::open(path)` è¿”å› `Result<File, io::Error>`
- æ­£åˆ™ç¼–è¯‘ï¼š`Regex::new(pattern)` è¿”å› `Result<Regex, Error>`
- é…ç½®è§£æï¼šå‘½ä»¤è¡Œå‚æ•°è§£æè¿”å› Result

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šOption<T> ç±»å‹ ğŸ“¦

**Option æ˜¯è¡¨ç¤º"æœ‰å€¼æˆ–æ— å€¼"çš„æšä¸¾ï¼Œæ›¿ä»£ null çš„å®‰å…¨æ–¹æ¡ˆ**

```rust
// Option çš„å®šä¹‰
enum Option<T> {
    Some(T),  // æœ‰å€¼
    None,     // æ— å€¼
}

// å®é™…ä½¿ç”¨
fn find_user(id: u32) -> Option<User> {
    // æ•°æ®åº“æŸ¥è¯¢...
    if found {
        Some(user)
    } else {
        None
    }
}

fn main() {
    match find_user(42) {
        Some(user) => println!("æ‰¾åˆ°ç”¨æˆ·: {}", user.name),
        None => println!("ç”¨æˆ·ä¸å­˜åœ¨"),
    }
}
```

**Option vs Result å¯¹æ¯”ï¼š**

| ç‰¹æ€§ | Option<T> | Result<T, E> |
|-----|-----------|--------------|
| è¯­ä¹‰ | å¯èƒ½æ— å€¼ | å¯èƒ½å¤±è´¥ |
| é”™è¯¯ä¿¡æ¯ | æ— ï¼ˆåªæœ‰ Noneï¼‰| æœ‰ï¼ˆE åŒ…å«é”™è¯¯è¯¦æƒ…ï¼‰|
| ä½¿ç”¨åœºæ™¯ | æŸ¥æ‰¾ã€å¯é€‰å­—æ®µ | IOã€è§£æã€éªŒè¯ |
| è½¬æ¢æ–¹æ³• | `ok_or(e)` â†’ Result | `ok()` â†’ Option |

**å¸¸ç”¨æ–¹æ³•ï¼š**

```rust
let name: Option<String> = Some("Alice".to_string());

// è·å–å€¼
let n = name.unwrap();                    // è·å–æˆ– panic
let n = name.unwrap_or("Unknown".into()); // è·å–æˆ–é»˜è®¤
let n = name.unwrap_or_default();         // è·å–æˆ–ç±»å‹é»˜è®¤å€¼

// è½¬æ¢
let upper = name.map(|s| s.to_uppercase());  // Some("ALICE")
let len = name.and_then(|s| Some(s.len()));  // Some(5)

// æ£€æŸ¥
if name.is_some() { /* ... */ }
if name.is_none() { /* ... */ }

// è½¬ä¸º Result
let result: Result<String, &str> = name.ok_or("æ²¡æœ‰åå­—");
```

**åœ¨ ripgrep æºç ä¸­çš„åº”ç”¨ï¼š**
- `str::find()` è¿”å› `Option<usize>` è¡¨ç¤ºåŒ¹é…ä½ç½®
- é…ç½®å­—æ®µçš„å¯é€‰å€¼
- è¿­ä»£å™¨çš„ `next()` è¿”å› `Option<Item>`

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼š? æ“ä½œç¬¦ â“

**? æ“ä½œç¬¦æ˜¯é”™è¯¯ä¼ æ’­çš„è¯­æ³•ç³–ï¼Œé‡åˆ° Err è‡ªåŠ¨ returnï¼Œé‡åˆ° Ok è§£åŒ…å€¼**

```rust
// æ²¡æœ‰ ? æ“ä½œç¬¦ï¼šæ‰‹åŠ¨å¤„ç†
fn read_config_verbose() -> Result<Config, io::Error> {
    let file = match File::open("config.txt") {
        Ok(f) => f,
        Err(e) => return Err(e),
    };
    let mut content = String::new();
    match file.read_to_string(&mut content) {
        Ok(_) => {},
        Err(e) => return Err(e),
    };
    // è§£æ content...
    Ok(config)
}

// ä½¿ç”¨ ? æ“ä½œç¬¦ï¼šç®€æ´æ˜äº†
fn read_config() -> Result<Config, io::Error> {
    let mut file = File::open("config.txt")?;  // å¤±è´¥åˆ™ç«‹å³è¿”å›
    let mut content = String::new();
    file.read_to_string(&mut content)?;        // å¤±è´¥åˆ™ç«‹å³è¿”å›
    // è§£æ content...
    Ok(config)
}
```

**? çš„å·¥ä½œåŸç†ï¼š**

```
è¡¨è¾¾å¼?
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ£€æŸ¥ Result/Option  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚           â”‚
    â–¼           â–¼
  Ok(v)       Err(e)
    â”‚           â”‚
    â–¼           â–¼
  è¿”å› v     From::from(e)
            è½¬æ¢é”™è¯¯ç±»å‹
                â”‚
                â–¼
           return Err(...)
```

**é“¾å¼ ? ä½¿ç”¨ï¼š**

```rust
fn process() -> Result<Data, Box<dyn Error>> {
    let content = std::fs::read_to_string("data.json")?;
    let data: Data = serde_json::from_str(&content)?;
    let validated = validate(data)?;
    Ok(validated)
}
```

**åœ¨ ripgrep æºç ä¸­çš„åº”ç”¨ï¼š**
- ? æ“ä½œç¬¦è´¯ç©¿æ•´ä¸ªä»£ç åº“
- é…åˆè‡ªå®šä¹‰é”™è¯¯ç±»å‹å®ç°ä¼˜é›…çš„é”™è¯¯ä¼ æ’­
- æ¯ä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œéƒ½ç”¨ ? æ ‡è®°

---

### æ‰©å±•æ¦‚å¿µ4ï¼španic! ä¸ unwrap ğŸ’¥

**panic! æ˜¯ä¸å¯æ¢å¤é”™è¯¯çš„å¤„ç†æ–¹å¼ï¼Œç¨‹åºç«‹å³ç»ˆæ­¢**

```rust
// æ˜¾å¼ panic
panic!("å‘ç”Ÿäº†ä¸å¯æ¢å¤çš„é”™è¯¯: {}", error_msg);

// éšå¼ panicï¼ˆè¿™äº›æ“ä½œå¤±è´¥æ—¶ä¼š panicï¼‰
let v = vec![1, 2, 3];
v[100];                    // ç´¢å¼•è¶Šç•Œ â†’ panic
Option::None.unwrap();     // unwrap None â†’ panic
Result::Err("oops").unwrap(); // unwrap Err â†’ panic
```

**panic vs Result çš„é€‰æ‹©ï¼š**

| ä½¿ç”¨ panic! | ä½¿ç”¨ Result |
|------------|-------------|
| ç¨‹åº bugï¼ˆä¸å˜é‡è¢«ç ´åï¼‰| é¢„æœŸå¯èƒ½å‘ç”Ÿçš„é”™è¯¯ |
| æ–­è¨€å¤±è´¥ | ç”¨æˆ·è¾“å…¥é”™è¯¯ |
| åŸå‹å¼€å‘å¿«é€Ÿå¤±è´¥ | IO é”™è¯¯ |
| æµ‹è¯•ä»£ç  | å¤–éƒ¨ä¾èµ–é”™è¯¯ |
| ä¸å¯èƒ½å‘ç”Ÿçš„æƒ…å†µ | å¯æ¢å¤çš„é”™è¯¯ |

**unwrap å®¶æ—å¯¹æ¯”ï¼š**

```rust
let result: Result<i32, &str> = Ok(42);

result.unwrap();            // 42ï¼Œå¤±è´¥åˆ™ panic
result.expect("åº”è¯¥æœ‰å€¼");   // 42ï¼Œå¤±è´¥åˆ™ panic å¹¶æ˜¾ç¤ºæ¶ˆæ¯
result.unwrap_or(0);        // 42ï¼Œå¤±è´¥åˆ™è¿”å› 0
result.unwrap_or_default(); // 42ï¼Œå¤±è´¥åˆ™è¿”å› i32 é»˜è®¤å€¼ 0
result.unwrap_or_else(|e| { // 42ï¼Œå¤±è´¥åˆ™è°ƒç”¨é—­åŒ…
    log_error(e);
    0
});
```

---

### æ‰©å±•æ¦‚å¿µ5ï¼šè‡ªå®šä¹‰é”™è¯¯ç±»å‹ ğŸ”§

**è‡ªå®šä¹‰é”™è¯¯ç±»å‹ç”¨äºç»Ÿä¸€ä¸åŒæ¥æºçš„é”™è¯¯ï¼Œæä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯**

```rust
use std::fmt;
use std::io;
use std::num::ParseIntError;

// å®šä¹‰é”™è¯¯æšä¸¾
#[derive(Debug)]
enum SearchError {
    Io(io::Error),
    Parse(ParseIntError),
    InvalidPattern(String),
    NotFound { path: String },
}

// å®ç° Displayï¼ˆç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯ï¼‰
impl fmt::Display for SearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SearchError::Io(e) => write!(f, "IO é”™è¯¯: {}", e),
            SearchError::Parse(e) => write!(f, "è§£æé”™è¯¯: {}", e),
            SearchError::InvalidPattern(p) => write!(f, "æ— æ•ˆçš„æ¨¡å¼: {}", p),
            SearchError::NotFound { path } => write!(f, "æ–‡ä»¶æœªæ‰¾åˆ°: {}", path),
        }
    }
}

// å®ç° Error trait
impl std::error::Error for SearchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            SearchError::Io(e) => Some(e),
            SearchError::Parse(e) => Some(e),
            _ => None,
        }
    }
}

// å®ç° From traitï¼Œæ”¯æŒ ? è‡ªåŠ¨è½¬æ¢
impl From<io::Error> for SearchError {
    fn from(e: io::Error) -> Self {
        SearchError::Io(e)
    }
}

impl From<ParseIntError> for SearchError {
    fn from(e: ParseIntError) -> Self {
        SearchError::Parse(e)
    }
}
```

**ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ï¼š**

```rust
fn search(pattern: &str, path: &str) -> Result<Vec<String>, SearchError> {
    if pattern.is_empty() {
        return Err(SearchError::InvalidPattern("æ¨¡å¼ä¸èƒ½ä¸ºç©º".into()));
    }

    let content = std::fs::read_to_string(path)?;  // io::Error è‡ªåŠ¨è½¬æ¢
    let max_lines: usize = "100".parse()?;         // ParseIntError è‡ªåŠ¨è½¬æ¢

    // æœç´¢é€»è¾‘...
    Ok(results)
}
```

---

### æ‰©å±•æ¦‚å¿µ6ï¼šError trait ä¸ thiserror/anyhow ğŸ“š

**std::error::Error trait æ˜¯ Rust é”™è¯¯ç±»å‹çš„æ ‡å‡†æ¥å£**

```rust
pub trait Error: Debug + Display {
    // è¿”å›å¯¼è‡´æ­¤é”™è¯¯çš„åº•å±‚é”™è¯¯ï¼ˆå¯é€‰ï¼‰
    fn source(&self) -> Option<&(dyn Error + 'static)> { None }
}
```

**thiserror crateï¼ˆæ¨èç”¨äºåº“å¼€å‘ï¼‰ï¼š**

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum SearchError {
    #[error("IO é”™è¯¯: {0}")]
    Io(#[from] std::io::Error),

    #[error("æ— æ•ˆçš„æ­£åˆ™: {0}")]
    Regex(#[from] regex::Error),

    #[error("æ–‡ä»¶æœªæ‰¾åˆ°: {path}")]
    NotFound { path: String },

    #[error("æœç´¢è¶…æ—¶ï¼Œå·²å¤„ç† {processed} ä¸ªæ–‡ä»¶")]
    Timeout { processed: usize },
}
```

**anyhow crateï¼ˆæ¨èç”¨äºåº”ç”¨å¼€å‘ï¼‰ï¼š**

```rust
use anyhow::{Context, Result, bail, anyhow};

fn read_config(path: &str) -> Result<Config> {
    let content = std::fs::read_to_string(path)
        .context("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥")?;

    let config: Config = toml::from_str(&content)
        .context("è§£æé…ç½®æ–‡ä»¶å¤±è´¥")?;

    if config.threads == 0 {
        bail!("çº¿ç¨‹æ•°ä¸èƒ½ä¸º 0");  // å¿«é€Ÿè¿”å›é”™è¯¯
    }

    Ok(config)
}

fn main() -> Result<()> {
    let config = read_config("config.toml")?;

    // anyhow æä¾›å®Œæ•´çš„é”™è¯¯é“¾
    // é”™è¯¯ä¿¡æ¯ç¤ºä¾‹ï¼š
    // Error: è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥
    //
    // Caused by:
    //     No such file or directory (os error 2)

    Ok(())
}
```

**thiserror vs anyhow é€‰æ‹©ï¼š**

| ç‰¹æ€§ | thiserror | anyhow |
|-----|-----------|--------|
| ç”¨é€” | åº“å¼€å‘ | åº”ç”¨å¼€å‘ |
| é”™è¯¯ç±»å‹ | è‡ªå®šä¹‰æšä¸¾ | é€šç”¨ `anyhow::Error` |
| ç±»å‹ä¿¡æ¯ | ä¿ç•™ï¼ˆå¯æ¨¡å¼åŒ¹é…ï¼‰| æ“¦é™¤ï¼ˆåŠ¨æ€ç±»å‹ï¼‰|
| ä½¿ç”¨å¤æ‚åº¦ | è¾ƒé«˜ï¼ˆéœ€å®šä¹‰ç±»å‹ï¼‰| è¾ƒä½ï¼ˆç›´æ¥ä½¿ç”¨ï¼‰|
| é”™è¯¯é“¾ | æ‰‹åŠ¨å®ç° | è‡ªåŠ¨æ”¯æŒ |

**ripgrep æºç ä¸­çš„åº”ç”¨ï¼š**
- å„ä¸ª crateï¼ˆgrep-searcherã€grep-printerã€ignoreï¼‰å®šä¹‰è‡ªå·±çš„é”™è¯¯ç±»å‹
- ä½¿ç”¨ç±»ä¼¼ thiserror çš„æ¨¡å¼
- é”™è¯¯ä¿¡æ¯æœ€ç»ˆæ ¼å¼åŒ–å±•ç¤ºç»™ç”¨æˆ·

---

## ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹ 20% çš„æ ¸å¿ƒçŸ¥è¯†ï¼Œå°±èƒ½è§£å†³ 80% çš„é”™è¯¯å¤„ç†é—®é¢˜ï¼š

### 4.1 ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯

```rust
fn read_and_parse(path: &str) -> Result<Data, Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string(path)?;  // å¤±è´¥è‡ªåŠ¨è¿”å›
    let data: Data = serde_json::from_str(&content)?;
    Ok(data)
}
```

**è¦ç‚¹ï¼š** å‡½æ•°è¿”å›ç±»å‹å¿…é¡»æ˜¯ `Result<T, E>` æ‰èƒ½ä½¿ç”¨ `?`

### 4.2 ä½¿ç”¨ unwrap_or å¤„ç† Option

```rust
// æœ‰é»˜è®¤å€¼æ—¶
let port = config.port.unwrap_or(8080);

// é»˜è®¤å€¼éœ€è¦è®¡ç®—æ—¶
let name = user.name.unwrap_or_else(|| generate_default_name());

// ä½¿ç”¨ç±»å‹é»˜è®¤å€¼
let count = maybe_count.unwrap_or_default();  // 0 for integers
```

### 4.3 ä½¿ç”¨ map/map_err è½¬æ¢ç±»å‹

```rust
// è½¬æ¢æˆåŠŸå€¼
let upper: Option<String> = name.map(|s| s.to_uppercase());

// è½¬æ¢é”™è¯¯ç±»å‹
let result = file.read(&mut buf)
    .map_err(|e| format!("è¯»å–å¤±è´¥: {}", e))?;
```

### 4.4 ä½¿ç”¨ if let / match å¤„ç†é”™è¯¯

```rust
// if letï¼šåªå…³å¿ƒæˆåŠŸæƒ…å†µ
if let Ok(file) = File::open("config.txt") {
    // ä½¿ç”¨ file
}

// matchï¼šå¤„ç†æ‰€æœ‰æƒ…å†µ
match File::open("config.txt") {
    Ok(file) => process(file),
    Err(e) if e.kind() == ErrorKind::NotFound => use_default(),
    Err(e) => return Err(e.into()),
}
```

### 4.5 å‡½æ•°ç­¾åä½¿ç”¨ Result

```rust
// ç®€å•æ–¹å¼ï¼šBox<dyn Error>
fn simple() -> Result<(), Box<dyn std::error::Error>> {
    // å¯ä»¥è¿”å›ä»»ä½•å®ç°äº† Error çš„ç±»å‹
    Ok(())
}

// åº”ç”¨å¼€å‘ï¼šanyhow
fn app() -> anyhow::Result<()> {
    Ok(())
}

// åº“å¼€å‘ï¼šè‡ªå®šä¹‰é”™è¯¯ç±»å‹
fn library() -> Result<Data, MyError> {
    Ok(data)
}
```

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- å¤„ç†å¤§éƒ¨åˆ†æ–‡ä»¶ IO é”™è¯¯
- ç¼–å†™è¿”å› Result çš„å‡½æ•°
- ä½¿ç”¨ ? è¿›è¡Œé”™è¯¯ä¼ æ’­
- ä¸ºåç»­å­¦ä¹  thiserror/anyhow æ‰“åŸºç¡€

---

## ã€ç±»æ¯”ã€‘

### ç±»æ¯”1ï¼šResult = Promise / è€ƒè¯•æˆç»©å•

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šResult ç±»ä¼¼ Promise

```javascript
// JavaScript Promise
async function fetchData() {
    try {
        const response = await fetch(url);
        const data = await response.json();
        return data;
    } catch (error) {
        throw new Error(`è·å–æ•°æ®å¤±è´¥: ${error}`);
    }
}

// å¤„ç†
fetchData()
    .then(data => console.log(data))
    .catch(err => console.error(err));
```

```rust
// Rust Result
fn fetch_data() -> Result<Data, Error> {
    let response = fetch(url)?;
    let data = response.json()?;
    Ok(data)
}

// å¤„ç†
match fetch_data() {
    Ok(data) => println!("{:?}", data),
    Err(e) => eprintln!("{}", e),
}
```

**å…³é”®åŒºåˆ«ï¼š** Rust çš„ Result æ˜¯åŒæ­¥çš„ã€å¿…é¡»æ˜¾å¼å¤„ç†ï¼ŒPromise å¯ä»¥è¢«å¿½ç•¥

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šResult = è€ƒè¯•æˆç»©å•

æƒ³è±¡ä½ å‚åŠ äº†ä¸€æ¬¡è€ƒè¯•ï¼š

- `Ok(score)` = è€ƒè¯•é€šè¿‡äº†ï¼ä½ çš„åˆ†æ•°æ˜¯å¤šå°‘
- `Err(reason)` = è€ƒè¯•æ²¡é€šè¿‡ï¼ŒåŸå› æ˜¯ä»€ä¹ˆï¼ˆæ¯”å¦‚ï¼šç¼ºè€ƒã€ç­”é¢˜å¡æ¶‚é”™äº†ï¼‰

```rust
enum è€ƒè¯•ç»“æœ {
    é€šè¿‡(åˆ†æ•°),      // Ok(95)
    æ²¡é€šè¿‡(åŸå› ),    // Err("ç¼ºè€ƒ")
}
```

è€å¸ˆå‘æˆç»©å•æ—¶ï¼Œä½ **å¿…é¡»**æ‰“å¼€çœ‹ï¼š
- é€šè¿‡äº† â†’ å¼€å¿ƒåœ°å‘Šè¯‰çˆ¸å¦ˆåˆ†æ•°
- æ²¡é€šè¿‡ â†’ å‘Šè¯‰çˆ¸å¦ˆåŸå› ï¼Œæƒ³åŠæ³•è¡¥æ•‘

---

### ç±»æ¯”2ï¼šOption = å¯é€‰é“¾ / æ‰¾ä¸œè¥¿

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šOption ç±»ä¼¼å¯é€‰é“¾

```javascript
// JavaScript å¯é€‰é“¾å’Œç©ºå€¼åˆå¹¶
const name = user?.profile?.name ?? "Anonymous";

// ç­‰ä»·äº
const name = user && user.profile && user.profile.name
    ? user.profile.name
    : "Anonymous";
```

```rust
// Rust Option
let name = user
    .as_ref()
    .and_then(|u| u.profile.as_ref())
    .map(|p| p.name.clone())
    .unwrap_or_else(|| "Anonymous".to_string());

// æˆ–æ›´ç®€æ´
let name = user
    .and_then(|u| u.profile)
    .map(|p| p.name)
    .unwrap_or("Anonymous".into());
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šOption = åœ¨æˆ¿é—´æ‰¾ä¸œè¥¿

å¦ˆå¦ˆè®©ä½ å»æˆ¿é—´æ‰¾çº¢è‰²çš„çƒï¼š

- `Some(ball)` = æ‰¾åˆ°äº†ï¼è¿™æ˜¯é‚£ä¸ªçº¢çƒ
- `None` = æ²¡æ‰¾åˆ°ï¼Œæˆ¿é—´é‡Œæ²¡æœ‰çº¢çƒ

```rust
enum æ‰¾ä¸œè¥¿ç»“æœ {
    æ‰¾åˆ°äº†(çº¢çƒ),   // Some(ball)
    æ²¡æ‰¾åˆ°,         // None
}
```

å¦‚æœæ‰¾åˆ°äº†ï¼Œä½ å°±æ‹¿ç€çƒå‡ºæ¥ï¼›å¦‚æœæ²¡æ‰¾åˆ°ï¼Œä½ å¯ä»¥ï¼š
- `unwrap()` = åšæŒè¯´"ä¸€å®šæœ‰ï¼"ç„¶åç¿»éæˆ¿é—´ï¼ˆå¯èƒ½æå¾—ä¸€å›¢ç³Ÿï¼‰
- `unwrap_or(å¤‡ç”¨çƒ)` = æ²¡æ‰¾åˆ°å°±ç”¨è“è‰²çƒä»£æ›¿

---

### ç±»æ¯”3ï¼š? æ“ä½œç¬¦ = await / ä¼ è¯ç­’

#### ğŸ¨ å‰ç«¯è§†è§’ï¼š? ç±»ä¼¼ awaitï¼ˆä½†æ›´æ˜¾å¼ï¼‰

```javascript
// JavaScript - å¼‚å¸¸ä¼šéšå¼ä¼ æ’­
async function processOrder() {
    const user = await getUser();     // å¯èƒ½æŠ›å‡º
    const cart = await getCart(user); // å¯èƒ½æŠ›å‡º
    const order = await checkout(cart); // å¯èƒ½æŠ›å‡º
    return order;
}
// è°ƒç”¨è€…å¯èƒ½ä¸çŸ¥é“å“ªé‡Œä¼šæŠ›å‡ºå¼‚å¸¸
```

```rust
// Rust - ? è®©æ¯ä¸ªå¯èƒ½å¤±è´¥çš„ç‚¹æ˜¾å¼å¯è§
fn process_order() -> Result<Order, Error> {
    let user = get_user()?;      // æ˜¾å¼ï¼šè¿™é‡Œå¯èƒ½å¤±è´¥
    let cart = get_cart(&user)?; // æ˜¾å¼ï¼šè¿™é‡Œå¯èƒ½å¤±è´¥
    let order = checkout(&cart)?; // æ˜¾å¼ï¼šè¿™é‡Œå¯èƒ½å¤±è´¥
    Ok(order)
}
// ä¸€çœ¼å°±èƒ½çœ‹åˆ°ä¸‰ä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œ
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼š? = ä¼ è¯ç­’æ¸¸æˆ

ä½ è®©å°æ˜å»é—®è€å¸ˆè¦ä½œä¸šç­”æ¡ˆï¼š

**æ²¡æœ‰ ? çš„æƒ…å†µï¼ˆæ‰‹åŠ¨ä¼ è¯ï¼‰ï¼š**
```
ä½ ï¼šå°æ˜ï¼Œå»é—®è€å¸ˆç­”æ¡ˆ
å°æ˜ï¼šè€å¸ˆè¯´äº†...ï¼ˆç­‰å°æ˜å›æ¥ï¼‰
ä½ ï¼šè€å¸ˆæ€ä¹ˆè¯´ï¼Ÿ
å°æ˜ï¼šè€å¸ˆç»™äº†ç­”æ¡ˆ / è€å¸ˆè¯´æ²¡æœ‰
ä½ ï¼šï¼ˆæ ¹æ®å›ç­”å†³å®šä¸‹ä¸€æ­¥ï¼‰
```

**æœ‰ ? çš„æƒ…å†µï¼ˆè‡ªåŠ¨ä¼ è¯ï¼‰ï¼š**
```
ä½ ï¼šå°æ˜ï¼Œå»é—®è€å¸ˆç­”æ¡ˆ?
å¦‚æœè€å¸ˆç»™äº† â†’ å°æ˜ç›´æ¥æŠŠç­”æ¡ˆå¸¦å›æ¥ï¼Œæ¸¸æˆç»§ç»­
å¦‚æœè€å¸ˆè¯´æ²¡æœ‰ â†’ å°æ˜å–Š"æ²¡æœ‰ï¼"ï¼Œæ¸¸æˆç»“æŸ
```

---

### ç±»æ¯”4ï¼španic! = throw Error / è­¦æŠ¥å¤§ä½œ

#### ğŸ¨ å‰ç«¯è§†è§’ï¼španic! ç±»ä¼¼ throw

```javascript
// JavaScript throw
function divide(a, b) {
    if (b === 0) {
        throw new Error("é™¤æ•°ä¸èƒ½ä¸ºé›¶ï¼");
    }
    return a / b;
}
```

```rust
// Rust panic!
fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("é™¤æ•°ä¸èƒ½ä¸ºé›¶ï¼");
    }
    a / b
}
```

**åŒºåˆ«ï¼š** Rust çš„ panic é»˜è®¤ä¼šç»ˆæ­¢ç¨‹åºï¼Œä¸åƒ JS çš„å¼‚å¸¸å¯ä»¥è¢« catch

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼španic! = æ‹‰å“è­¦æŠ¥ç„¶åè·‘æ‰

æƒ³è±¡ä½ åœ¨å›¾ä¹¦é¦†ï¼š

- `Result::Err` = è½»å£°å‘Šè¯‰ç®¡ç†å‘˜"è¿™æœ¬ä¹¦æ‰¾ä¸åˆ°"
- `panic!` = å¤§å–Š"ç€ç«äº†ï¼"ç„¶åå†²å‡ºå›¾ä¹¦é¦†

panic æ˜¯ç´§æ€¥æƒ…å†µçš„å¤„ç†æ–¹å¼ï¼Œä¸åº”è¯¥ç”¨äºæ™®é€šçš„"æ‰¾ä¸åˆ°ä¹¦"è¿™ç§æƒ…å†µã€‚

---

### ç±»æ¯”æ€»ç»“è¡¨

| Rust æ¦‚å¿µ | å‰ç«¯ç±»æ¯” | å°æœ‹å‹ç±»æ¯” |
|----------|---------|-----------|
| `Result<T, E>` | Promise (resolve/reject) | è€ƒè¯•æˆç»©å•ï¼ˆé€šè¿‡/ä¸é€šè¿‡+åŸå› ï¼‰|
| `Option<T>` | å¯é€‰é“¾ `?.` / `??` | æ‰¾ä¸œè¥¿ï¼ˆæ‰¾åˆ°/æ²¡æ‰¾åˆ°ï¼‰|
| `?` æ“ä½œç¬¦ | awaitï¼ˆä½†æ›´æ˜¾å¼ï¼‰ | ä¼ è¯ç­’æ¸¸æˆ |
| `unwrap()` | ç›´æ¥ `.then()` å–å€¼ | å¼ºè¡Œæ‰“å¼€ç›’å­ |
| `unwrap_or()` | `?? default` | æ²¡æ‰¾åˆ°å°±ç”¨å¤‡ç”¨çš„ |
| `map()` | `.then(v => ...)` | æŠŠæ‰¾åˆ°çš„ä¸œè¥¿å˜ä¸€å˜ |
| `and_then()` | `.then()` è¿”å›æ–° Promise | æ‰¾åˆ°åç»§ç»­æ‰¾ä¸‹ä¸€ä¸ª |
| `panic!` | `throw Error` | æ‹‰å“è­¦æŠ¥è·‘æ‰ |
| `Ok(v)` | `Promise.resolve(v)` | è€ƒè¯•é€šè¿‡ |
| `Err(e)` | `Promise.reject(e)` | è€ƒè¯•æ²¡é€šè¿‡ |
| `Some(v)` | å€¼å­˜åœ¨ | æ‰¾åˆ°äº† |
| `None` | `null/undefined` | æ²¡æ‰¾åˆ° |

---

## ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼š"unwrap å¾ˆæ–¹ä¾¿ï¼Œåˆ°å¤„ç”¨" âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- `unwrap()` åœ¨é‡åˆ° `Err/None` æ—¶ä¼šå¯¼è‡´ç¨‹åº panic
- ç”Ÿäº§ä»£ç ä¸­ panic æ„å‘³ç€æœåŠ¡å´©æºƒã€ç”¨æˆ·ä½“éªŒå·®
- éšè—äº†çœŸæ­£çš„é”™è¯¯ä¿¡æ¯ï¼Œéš¾ä»¥è°ƒè¯•

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
- ä»æœ‰å¼‚å¸¸çš„è¯­è¨€æ¥ï¼Œä¹ æƒ¯äº†"å…ˆå†™å®Œå†å¤„ç†å¼‚å¸¸"
- æ•™ç¨‹ç¤ºä¾‹ä¸ºäº†ç®€æ´å¤§é‡ä½¿ç”¨ unwrap
- ç¼–è¯‘èƒ½é€šè¿‡å°±ä»¥ä¸ºæ²¡é—®é¢˜
- å¼€å‘æ—¶æ€»æ˜¯"æ­£å¸¸è·¯å¾„"ï¼Œæ²¡é‡åˆ°é”™è¯¯

**æ­£ç¡®ç†è§£ï¼š**

```rust
// âŒ å±é™©ï¼šç”Ÿäº§ä»£ç åˆ°å¤„ç”¨ unwrap
fn process_config() {
    let content = fs::read_to_string("config.txt").unwrap();
    let config: Config = serde_json::from_str(&content).unwrap();
    // ä»»ä½•ä¸€æ­¥å¤±è´¥ï¼Œæ•´ä¸ªç¨‹åºå´©æºƒ
}

// âœ… æ­£ç¡®ï¼šä¼ æ’­é”™è¯¯
fn process_config() -> Result<Config, Box<dyn Error>> {
    let content = fs::read_to_string("config.txt")?;
    let config: Config = serde_json::from_str(&content)?;
    Ok(config)
}

// âœ… æ­£ç¡®ï¼šæä¾›é»˜è®¤å€¼
fn get_port() -> u16 {
    env::var("PORT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(8080)
}

// âœ… å¯æ¥å—ï¼šç¡®å®ä¸å¯èƒ½å¤±è´¥æ—¶ç”¨ expect è¯´æ˜åŸå› 
let regex = Regex::new(r"^\d+$").expect("ç¡¬ç¼–ç çš„æ­£åˆ™ä¸å¯èƒ½å¤±è´¥");
```

---

### è¯¯åŒº2ï¼š"Result å’Œå¼‚å¸¸ä¸€æ ·" âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- Result æ˜¯**è¿”å›å€¼**ï¼Œå¿…é¡»åœ¨æ¯ä¸€å±‚æ˜¾å¼å¤„ç†æˆ–ä¼ æ’­
- å¼‚å¸¸å¯ä»¥è·¨å¤šå±‚**éšå¼ä¼ æ’­**ï¼Œä¸­é—´å±‚å¯ä»¥å®Œå…¨ä¸çŸ¥é“
- Result æ²¡æœ‰æ€§èƒ½å¼€é”€ï¼ˆæ— å¼‚å¸¸è¡¨ï¼‰ï¼Œå¼‚å¸¸æœ‰æ ˆå±•å¼€å¼€é”€

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
- ä» Java/Python/JavaScript æ¥ï¼Œä¹ æƒ¯äº†å¼‚å¸¸æœºåˆ¶
- Result å’Œå¼‚å¸¸éƒ½æ˜¯"å¤„ç†é”™è¯¯"ï¼ŒåŠŸèƒ½ç›¸ä¼¼
- ? æ“ä½œç¬¦çœ‹èµ·æ¥åƒæ˜¯"è‡ªåŠ¨ä¼ æ’­"

**æ­£ç¡®ç†è§£ï¼š**

```rust
// Rust: é”™è¯¯å¿…é¡»åœ¨æ¯ä¸€å±‚æ˜¾å¼å¤„ç†æˆ–ä¼ æ’­
fn level3() -> Result<(), Error> {
    may_fail()?  // å¿…é¡»å†™ ?
}

fn level2() -> Result<(), Error> {
    level3()?    // å¿…é¡»å†™ ?
}

fn level1() -> Result<(), Error> {
    level2()?    // å¿…é¡»å†™ ?
}
// æ¯ä¸€å±‚éƒ½å¿…é¡»æ˜¾å¼å£°æ˜"æˆ‘ä¼šä¼ æ’­é”™è¯¯"
```

```java
// Java: å¼‚å¸¸éšå¼ä¼ æ’­ï¼ˆunchecked exceptionï¼‰
void level3() {
    mayFail();  // å¯èƒ½æŠ›å‡º RuntimeException
}

void level2() {
    level3();   // è‡ªåŠ¨ä¼ æ’­ï¼Œä¸ç”¨å†™ä»»ä½•ä¸œè¥¿
}

void level1() {
    level2();   // è‡ªåŠ¨ä¼ æ’­
}
// ä¸­é—´å±‚å®Œå…¨ä¸çŸ¥é“æœ‰å¼‚å¸¸åœ¨ä¼ æ’­
```

**å…³é”®åŒºåˆ«å¯è§†åŒ–ï¼š**

```
Rust Result ä¼ æ’­ï¼š
level1 â”€?â†’ level2 â”€?â†’ level3 â”€?â†’ may_fail
  â†‘           â†‘          â†‘          â†‘
æ¯ä¸€å±‚éƒ½æ˜¾å¼æ ‡è®°é”™è¯¯ä¼ æ’­

Java Exception ä¼ æ’­ï¼š
level1 â”€â”€â†’ level2 â”€â”€â†’ level3 â”€â”€â†’ mayFail
                                   â†“
                              æŠ›å‡ºå¼‚å¸¸
  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        å¼‚å¸¸éšå¼ç©¿é€æ‰€æœ‰å±‚çº§
```

---

### è¯¯åŒº3ï¼š"Option::None å’Œ null ä¸€æ ·" âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- Option æ˜¯ç±»å‹ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼Œ**ç¼–è¯‘å™¨å¼ºåˆ¶æ£€æŸ¥**
- null å¯ä»¥å‡ºç°åœ¨ä»»ä½•å¼•ç”¨ä½ç½®ï¼Œç¼–è¯‘å™¨ä¸ç®¡
- Option å¿…é¡»æ˜¾å¼å¤„ç† None æƒ…å†µï¼Œä¸å¤„ç†ç¼–è¯‘ä¸è¿‡
- null ç›´åˆ°è¿è¡Œæ—¶è®¿é—®æ‰ä¼šçˆ†ç‚¸ï¼ˆNullPointerExceptionï¼‰

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
- æ¦‚å¿µç›¸ä¼¼ï¼šéƒ½è¡¨ç¤º"æ— å€¼"
- å…¶ä»–è¯­è¨€çš„ Optional ç±»å‹ï¼ˆå¦‚ Javaï¼‰å¯ä»¥è¢«ç»•è¿‡
- çœ‹èµ·æ¥ None å°±æ˜¯ null çš„å¦ä¸€ä¸ªåå­—

**æ­£ç¡®ç†è§£ï¼š**

```rust
// Rust Optionï¼šç¼–è¯‘å™¨å¼ºåˆ¶å¤„ç† None
fn get_name(user: Option<User>) -> String {
    // user.name  // âŒ ç¼–è¯‘é”™è¯¯ï¼Option<User> æ²¡æœ‰ name å­—æ®µ

    // âœ… å¿…é¡»æ˜¾å¼å¤„ç†
    match user {
        Some(u) => u.name,
        None => "Anonymous".to_string(),
    }

    // æˆ–è€…
    user.map(|u| u.name).unwrap_or_else(|| "Anonymous".to_string())
}
```

```java
// Java nullï¼šè¿è¡Œæ—¶æ‰çˆ†ç‚¸
String getName(User user) {
    return user.name;  // ç¼–è¯‘é€šè¿‡ï¼
    // ä½†å¦‚æœ user æ˜¯ null â†’ NullPointerException
}

// Java Optionalï¼šå¯ä»¥è¢«ç»•è¿‡
Optional<User> maybeUser = getUser();
User user = maybeUser.get();  // å¦‚æœæ˜¯ emptyï¼ŒæŠ›å‡º NoSuchElementException
// ä½†ä½ ä»ç„¶å¯ä»¥å†™è¿™æ ·çš„ä»£ç ï¼Œç¼–è¯‘å™¨ä¸é˜»æ­¢
```

**ç±»å‹ç³»ç»Ÿä¿è¯å¯è§†åŒ–ï¼š**

```
Rust Option<User>:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Option<User>                       â”‚
â”‚  â”œâ”€ Some(User) â† å¯ä»¥è®¿é—® user.name â”‚
â”‚  â””â”€ None       â† å¿…é¡»å¤„ç†è¿™ç§æƒ…å†µ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ç¼–è¯‘å™¨ï¼š"ä½ ä¸å¤„ç† Noneï¼Œæˆ‘å°±ä¸è®©ä½ ç¼–è¯‘"

Java User (å¯èƒ½ä¸º null):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User (å¯èƒ½æ˜¯ null)                 â”‚
â”‚  â””â”€ user.name â† ç¼–è¯‘é€šè¿‡           â”‚
â”‚                 è¿è¡Œæ—¶å¯èƒ½ NPE      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ç¼–è¯‘å™¨ï¼š"æˆ‘ä¸ç®¡ï¼Œä½ è‡ªå·±å°å¿ƒ"
```

---

## ã€å®æˆ˜ä»£ç ã€‘

```rust
//! ç¤ºä¾‹ï¼šripgrep é£æ ¼çš„é”™è¯¯å¤„ç†
//! æ¼”ç¤º Resultã€Optionã€? æ“ä½œç¬¦åœ¨å®é™…åœºæ™¯ä¸­çš„åº”ç”¨
//!
//! è¿è¡Œæ–¹å¼ï¼šå°†ä»£ç ä¿å­˜ä¸º main.rsï¼Œç„¶å `cargo run`

use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;
use std::fmt;

// ===== 1. è‡ªå®šä¹‰é”™è¯¯ç±»å‹ =====

/// æœç´¢é”™è¯¯ç±»å‹ï¼Œç»Ÿä¸€ä¸åŒæ¥æºçš„é”™è¯¯
#[derive(Debug)]
enum SearchError {
    /// IO é”™è¯¯ï¼ˆæ–‡ä»¶è¯»å–å¤±è´¥ç­‰ï¼‰
    Io(io::Error),
    /// æ— æ•ˆçš„æœç´¢æ¨¡å¼
    InvalidPattern(String),
    /// æ–‡ä»¶æœªæ‰¾åˆ°
    NotFound { path: String },
}

impl fmt::Display for SearchError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SearchError::Io(e) => write!(f, "IO é”™è¯¯: {}", e),
            SearchError::InvalidPattern(p) => write!(f, "æ— æ•ˆçš„æ¨¡å¼: {}", p),
            SearchError::NotFound { path } => write!(f, "æ–‡ä»¶æœªæ‰¾åˆ°: {}", path),
        }
    }
}

impl std::error::Error for SearchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            SearchError::Io(e) => Some(e),
            _ => None,
        }
    }
}

// å®ç° From traitï¼Œæ”¯æŒ ? è‡ªåŠ¨è½¬æ¢
impl From<io::Error> for SearchError {
    fn from(e: io::Error) -> Self {
        SearchError::Io(e)
    }
}

// ===== 2. ä½¿ç”¨ ? æ“ä½œç¬¦çš„æœç´¢å‡½æ•° =====

/// åœ¨æ–‡ä»¶ä¸­æœç´¢åŒ…å«æŒ‡å®šæ¨¡å¼çš„è¡Œ
///
/// # Arguments
/// * `pattern` - è¦æœç´¢çš„å­—ç¬¦ä¸²æ¨¡å¼
/// * `path` - æ–‡ä»¶è·¯å¾„
///
/// # Returns
/// * `Ok(Vec<(usize, String)>)` - åŒ¹é…çš„è¡Œå·å’Œå†…å®¹
/// * `Err(SearchError)` - æœç´¢è¿‡ç¨‹ä¸­çš„é”™è¯¯
fn search_in_file(pattern: &str, path: &Path) -> Result<Vec<(usize, String)>, SearchError> {
    // éªŒè¯ pattern
    if pattern.is_empty() {
        return Err(SearchError::InvalidPattern("æ¨¡å¼ä¸èƒ½ä¸ºç©º".into()));
    }

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if !path.exists() {
        return Err(SearchError::NotFound {
            path: path.display().to_string(),
        });
    }

    // æ‰“å¼€æ–‡ä»¶ï¼ˆ? è‡ªåŠ¨è½¬æ¢ io::Error â†’ SearchErrorï¼‰
    let file = File::open(path)?;
    let reader = BufReader::new(file);

    // æ”¶é›†åŒ¹é…çš„è¡Œ
    let matches: Vec<(usize, String)> = reader
        .lines()
        .enumerate()
        .filter_map(|(line_num, line_result)| {
            // å¤„ç†æ¯è¡Œå¯èƒ½çš„è¯»å–é”™è¯¯
            line_result.ok().and_then(|line| {
                if line.contains(pattern) {
                    Some((line_num + 1, line))
                } else {
                    None
                }
            })
        })
        .collect();

    Ok(matches)
}

// ===== 3. Option çš„é“¾å¼å¤„ç† =====

/// è·å–æ–‡ä»¶æ‰©å±•åï¼ˆå°å†™ï¼‰
fn get_file_extension(path: &Path) -> Option<String> {
    path.extension()           // Option<&OsStr>
        .and_then(|ext| ext.to_str())  // Option<&str>
        .map(|s| s.to_lowercase())      // Option<String>
}

/// åˆ¤æ–­æ˜¯å¦ä¸ºæ–‡æœ¬æ–‡ä»¶
fn is_text_file(path: &Path) -> bool {
    get_file_extension(path)
        .map(|ext| matches!(ext.as_str(), "txt" | "md" | "rs" | "toml" | "json"))
        .unwrap_or(false)
}

// ===== 4. æœç´¢å¤šä¸ªæ–‡ä»¶ =====

/// æœç´¢ç»“æœ
struct SearchResult {
    path: String,
    matches: Vec<(usize, String)>,
}

/// åœ¨å¤šä¸ªæ–‡ä»¶ä¸­æœç´¢
fn search_multiple_files(
    pattern: &str,
    paths: &[&Path],
) -> Vec<Result<SearchResult, SearchError>> {
    paths
        .iter()
        .filter(|p| is_text_file(p))  // åªæœç´¢æ–‡æœ¬æ–‡ä»¶
        .map(|path| {
            let matches = search_in_file(pattern, path)?;
            Ok(SearchResult {
                path: path.display().to_string(),
                matches,
            })
        })
        .collect()
}

// ===== 5. é”™è¯¯æ¢å¤ä¸é»˜è®¤å€¼ =====

/// é…ç½®ç»“æ„
#[derive(Debug, Default)]
struct SearchConfig {
    case_insensitive: bool,
    max_count: Option<usize>,
    context_lines: usize,
}

/// è¯»å–é…ç½®ï¼Œå¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å€¼
fn read_config_or_default(path: &Path) -> SearchConfig {
    std::fs::read_to_string(path)
        .ok()                           // Result â†’ Option
        .and_then(|content| parse_config(&content))
        .unwrap_or_default()            // å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å€¼
}

/// è§£æé…ç½®å†…å®¹
fn parse_config(content: &str) -> Option<SearchConfig> {
    Some(SearchConfig {
        case_insensitive: content.contains("case_insensitive=true"),
        max_count: content
            .lines()
            .find(|l| l.starts_with("max_count="))
            .and_then(|l| l.split('=').nth(1))
            .and_then(|n| n.trim().parse().ok()),
        context_lines: content
            .lines()
            .find(|l| l.starts_with("context="))
            .and_then(|l| l.split('=').nth(1))
            .and_then(|n| n.trim().parse().ok())
            .unwrap_or(0),
    })
}

// ===== 6. æ¼”ç¤ºä¸»å‡½æ•° =====

fn main() {
    println!("=== Rust é”™è¯¯å¤„ç†å®æˆ˜æ¼”ç¤º ===\n");

    // 1. åŸºæœ¬æœç´¢ï¼ˆæ¼”ç¤º Result å¤„ç†ï¼‰
    println!("--- 1. åŸºæœ¬æœç´¢ ---");
    let test_path = Path::new("Cargo.toml");

    match search_in_file("name", test_path) {
        Ok(matches) => {
            println!("åœ¨ {} ä¸­æ‰¾åˆ° {} å¤„åŒ¹é…:", test_path.display(), matches.len());
            for (line_num, content) in matches.iter().take(3) {
                println!("  è¡Œ {}: {}", line_num, content.trim());
            }
        }
        Err(e) => println!("æœç´¢å¤±è´¥: {}", e),
    }
    println!();

    // 2. æœç´¢ä¸å­˜åœ¨çš„æ–‡ä»¶ï¼ˆæ¼”ç¤ºé”™è¯¯å¤„ç†ï¼‰
    println!("--- 2. æœç´¢ä¸å­˜åœ¨çš„æ–‡ä»¶ ---");
    let missing_path = Path::new("ä¸å­˜åœ¨çš„æ–‡ä»¶.txt");

    match search_in_file("test", missing_path) {
        Ok(matches) => println!("æ‰¾åˆ° {} å¤„åŒ¹é…", matches.len()),
        Err(SearchError::NotFound { path }) => {
            println!("æ–‡ä»¶æœªæ‰¾åˆ°: {}", path);
        }
        Err(e) => println!("å…¶ä»–é”™è¯¯: {}", e),
    }
    println!();

    // 3. Option å¤„ç†ï¼ˆæ¼”ç¤ºæ–‡ä»¶æ‰©å±•åï¼‰
    println!("--- 3. Option å¤„ç† ---");
    let paths = ["main.rs", "Cargo.toml", "README.md", "no_extension"];
    for p in paths {
        let ext = get_file_extension(Path::new(p));
        println!("  {} çš„æ‰©å±•å: {:?}", p, ext);
    }
    println!();

    // 4. unwrap_or ä½¿ç”¨
    println!("--- 4. unwrap_or ä½¿ç”¨ ---");
    let maybe_name: Option<String> = None;
    let name = maybe_name.unwrap_or_else(|| "é»˜è®¤ç”¨æˆ·".to_string());
    println!("  ç”¨æˆ·å: {}", name);
    println!();

    // 5. é…ç½®è¯»å–ï¼ˆæ¼”ç¤ºé”™è¯¯æ¢å¤ï¼‰
    println!("--- 5. é…ç½®è¯»å– ---");
    let config = read_config_or_default(Path::new("search.conf"));
    println!("  é…ç½®: {:?}", config);
    println!();

    // 6. if let æ¨¡å¼
    println!("--- 6. if let æ¨¡å¼ ---");
    if let Some(ext) = get_file_extension(Path::new("Cargo.toml")) {
        println!("  Cargo.toml çš„æ‰©å±•åæ˜¯: {}", ext);
    }

    println!("\n=== æ¼”ç¤ºå®Œæˆ ===");
}
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**

```
=== Rust é”™è¯¯å¤„ç†å®æˆ˜æ¼”ç¤º ===

--- 1. åŸºæœ¬æœç´¢ ---
åœ¨ Cargo.toml ä¸­æ‰¾åˆ° 2 å¤„åŒ¹é…:
  è¡Œ 2: name = "error_handling_demo"
  è¡Œ 7: authors = ["Your Name"]

--- 2. æœç´¢ä¸å­˜åœ¨çš„æ–‡ä»¶ ---
æ–‡ä»¶æœªæ‰¾åˆ°: ä¸å­˜åœ¨çš„æ–‡ä»¶.txt

--- 3. Option å¤„ç† ---
  main.rs çš„æ‰©å±•å: Some("rs")
  Cargo.toml çš„æ‰©å±•å: Some("toml")
  README.md çš„æ‰©å±•å: Some("md")
  no_extension çš„æ‰©å±•å: None

--- 4. unwrap_or ä½¿ç”¨ ---
  ç”¨æˆ·å: é»˜è®¤ç”¨æˆ·

--- 5. é…ç½®è¯»å– ---
  é…ç½®: SearchConfig { case_insensitive: false, max_count: None, context_lines: 0 }

--- 6. if let æ¨¡å¼ ---
  Cargo.toml çš„æ‰©å±•åæ˜¯: toml

=== æ¼”ç¤ºå®Œæˆ ===
```

---

## ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜ï¼š"Rust çš„é”™è¯¯å¤„ç†å’Œå…¶ä»–è¯­è¨€æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"Rust ç”¨ Result å’Œ Option å¤„ç†é”™è¯¯ï¼Œè€Œä¸æ˜¯å¼‚å¸¸ã€‚Result æœ‰ Ok å’Œ Err ä¸¤ç§æƒ…å†µï¼Œç”¨ match æˆ– ? æ¥å¤„ç†ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **Rust é”™è¯¯å¤„ç†çš„ä¸‰ä¸ªæ ¸å¿ƒåŒºåˆ«ï¼š**
>
> **1. ç¼–è¯‘æ—¶å¼ºåˆ¶ vs è¿è¡Œæ—¶å¼‚å¸¸**
>
> Rust çš„ Result æ˜¯è¿”å›ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œç¼–è¯‘å™¨**å¼ºåˆ¶**ä½ å¤„ç†æ¯ä¸ªå¯èƒ½çš„é”™è¯¯ã€‚è¿™ä¸åƒ Java çš„ checked exception å¯ä»¥ç”¨ `throws` å£°æ˜ç»•è¿‡ï¼Œä¹Ÿä¸åƒ Python/JavaScript çš„å¼‚å¸¸å®Œå…¨æ˜¯è¿è¡Œæ—¶è¡Œä¸ºã€‚
>
> ```rust
> // ä¸å¤„ç† Resultï¼Œç¼–è¯‘å°±æŠ¥é”™
> let file = File::open("config.txt")?;
> ```
>
> **2. æ˜¾å¼ä¼ æ’­ vs éšå¼å†’æ³¡**
>
> `?` æ“ä½œç¬¦è®©é”™è¯¯ä¼ æ’­åœ¨ä»£ç ä¸­**æ¸…æ™°å¯è§**ã€‚æ¯ä¸€ä¸ªå¯èƒ½å¤±è´¥çš„è°ƒç”¨ç‚¹éƒ½æ˜¾å¼æ ‡è®°ï¼Œä»£ç é˜…è¯»è€…èƒ½ç«‹å³çŸ¥é“å“ªäº›æ“ä½œå¯èƒ½å¤±è´¥ã€é”™è¯¯ä¼šå¾€å“ªé‡Œä¼ æ’­ã€‚
>
> ```rust
> fn process() -> Result<Data, Error> {
>     let config = read_config()?;     // å¯èƒ½å¤±è´¥ç‚¹ 1
>     let data = fetch_data(&config)?; // å¯èƒ½å¤±è´¥ç‚¹ 2
>     validate(&data)?;                 // å¯èƒ½å¤±è´¥ç‚¹ 3
>     Ok(data)
> }
> ```
>
> **3. é›¶æˆæœ¬æŠ½è±¡ vs å¼‚å¸¸è¡¨å¼€é”€**
>
> Result åªæ˜¯æ™®é€šçš„æšä¸¾ç±»å‹ï¼Œ`?` æ“ä½œç¬¦ç¼–è¯‘ä¸ºç®€å•çš„æ¨¡å¼åŒ¹é…ã€‚æ²¡æœ‰å¼‚å¸¸è¡¨ã€æ ˆå±•å¼€ç­‰è¿è¡Œæ—¶å¼€é”€ã€‚è¿™å¯¹é«˜æ€§èƒ½åœºæ™¯ï¼ˆå¦‚ ripgrep æ¯ç§’æœç´¢æ•°ç™¾ä¸‡è¡Œï¼‰è‡³å…³é‡è¦ã€‚
>
> **åœ¨ ripgrep è¿™æ ·çš„å®é™…é¡¹ç›®ä¸­ï¼š**
> - ç”¨ **thiserror** å®šä¹‰åº“çš„é”™è¯¯ç±»å‹ï¼Œä¿ç•™ç±»å‹ä¿¡æ¯ä¾¿äºåŒ¹é…
> - ç”¨ **anyhow** åœ¨åº”ç”¨å±‚å¿«é€Ÿå¤„ç†ï¼Œæä¾›é”™è¯¯é“¾ä¸Šä¸‹æ–‡
> - è‡ªå®šä¹‰ Error æšä¸¾ç»Ÿä¸€ä¸åŒ crate çš„é”™è¯¯
> - æœ€ç»ˆå°†é”™è¯¯æ ¼å¼åŒ–ä¸ºç”¨æˆ·å‹å¥½çš„ä¿¡æ¯

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**

1. âœ… **å¯¹æ¯”å…¶ä»–è¯­è¨€**ï¼Œå±•ç¤ºç†è§£æ·±åº¦ï¼ˆä¸åªæ˜¯èƒŒå®šä¹‰ï¼‰
2. âœ… å¼ºè°ƒ**ç¼–è¯‘æ—¶å¼ºåˆ¶**è¿™ä¸ªæ ¸å¿ƒä¼˜åŠ¿
3. âœ… ç”¨**ä»£ç ç¤ºä¾‹**è¯´æ˜"æ˜¾å¼ä¼ æ’­"
4. âœ… æåˆ°**æ€§èƒ½ä¼˜åŠ¿**ï¼ˆé›¶æˆæœ¬ï¼‰ï¼Œä½“ç°ç³»ç»Ÿçº§æ€ç»´
5. âœ… è”ç³»**å®é™…é¡¹ç›®**ï¼ˆripgrepï¼‰ï¼Œå±•ç¤ºå®æˆ˜ç»éªŒ
6. âœ… æåˆ°**thiserror/anyhow**ï¼Œè¯´æ˜äº†è§£ç”Ÿæ€

---

### é—®é¢˜ï¼š"ä»€ä¹ˆæ—¶å€™ç”¨ panic!ï¼Œä»€ä¹ˆæ—¶å€™ç”¨ Resultï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"panic! æ˜¯ä¸å¯æ¢å¤é”™è¯¯ï¼ŒResult æ˜¯å¯æ¢å¤é”™è¯¯ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **åˆ¤æ–­æ ‡å‡†æ˜¯ï¼šè¿™ä¸ªé”™è¯¯æ˜¯ç¨‹åº bugï¼Œè¿˜æ˜¯é¢„æœŸä¸­å¯èƒ½å‘ç”Ÿçš„æƒ…å†µï¼Ÿ**
>
> **ç”¨ panic! çš„åœºæ™¯ï¼š**
> - **ç¨‹åº bug**ï¼šæ–­è¨€å¤±è´¥ã€ä¸å˜é‡è¢«ç ´å
> - **ä¸å¯èƒ½çš„æƒ…å†µ**ï¼šé€»è¾‘ä¸Šä¸å¯èƒ½åˆ°è¾¾çš„åˆ†æ”¯
> - **åŸå‹å¼€å‘**ï¼šå¿«é€Ÿå¤±è´¥ï¼Œåç»­å†æ”¹ä¸º Result
>
> ```rust
> // ç´¢å¼•è¶Šç•Œæ˜¯ç¨‹åº bug
> let v = vec![1, 2, 3];
> v[10];  // panic! è¿™æ˜¯æ­£ç¡®çš„è¡Œä¸º
>
> // ç¡¬ç¼–ç çš„æ­£åˆ™ä¸å¯èƒ½å¤±è´¥
> let re = Regex::new(r"^\d+$").expect("æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•é”™è¯¯æ˜¯ bug");
> ```
>
> **ç”¨ Result çš„åœºæ™¯ï¼š**
> - **é¢„æœŸå¯èƒ½å‘ç”Ÿ**çš„é”™è¯¯ï¼šç”¨æˆ·è¾“å…¥ã€æ–‡ä»¶ä¸å­˜åœ¨ã€ç½‘ç»œè¶…æ—¶
> - **è°ƒç”¨è€…èƒ½æœ‰æ„ä¹‰åœ°å¤„ç†**çš„é”™è¯¯
>
> ```rust
> // æ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µ
> fn read_config(path: &str) -> Result<Config, io::Error> {
>     let content = fs::read_to_string(path)?;
>     // ...
> }
> ```
>
> **åœ¨ ripgrep ä¸­çš„å®è·µï¼š**
> - ç”¨æˆ·æŒ‡å®šçš„æ–‡ä»¶ä¸å­˜åœ¨ â†’ Resultï¼ˆæ­£å¸¸æƒ…å†µï¼Œç»™å‡ºå‹å¥½æç¤ºï¼‰
> - æ­£åˆ™è¯­æ³•é”™è¯¯ â†’ Resultï¼ˆç”¨æˆ·è¾“å…¥é”™è¯¯ï¼‰
> - å†…éƒ¨æ•°æ®ç»“æ„ä¸ä¸€è‡´ â†’ panic!ï¼ˆè¿™æ˜¯ bugï¼Œåº”è¯¥ä¿®å¤ï¼‰

---

## ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šResult ç›´è§‰ç†è§£ ğŸ¯

**ä¸€å¥è¯ï¼š** Result æ˜¯"æˆåŠŸæˆ–å¤±è´¥"çš„ä¿¡å°ï¼Œæ‰“å¼€å‰å¿…é¡»æ£€æŸ¥æ ‡ç­¾

```rust
// Result å°±åƒä¸€ä¸ªä¿¡å°
// Ok(å†…å®¹) = ä¿¡å°é‡Œæœ‰ä½ è¦çš„ä¸œè¥¿
// Err(åŸå› ) = ä¿¡å°é‡Œæ˜¯æ‹’ç»ä¿¡ï¼Œå†™ç€ä¸ºä»€ä¹ˆä¸è¡Œ

let result: Result<String, &str> = Ok("ä½ çš„æ•°æ®".to_string());
let result: Result<String, &str> = Err("æ–‡ä»¶ä¸å­˜åœ¨");

// å¿…é¡»æ£€æŸ¥æ‰èƒ½æ‹¿åˆ°å†…å®¹
match result {
    Ok(data) => println!("æ‹¿åˆ°äº†: {}", data),
    Err(why) => println!("æ²¡æ‹¿åˆ°: {}", why),
}
```

**åº”ç”¨ï¼š** ripgrep æ‰“å¼€æ–‡ä»¶è¿”å› `Result<File, io::Error>`

---

### å¡ç‰‡2ï¼šOption ç›´è§‰ç†è§£ ğŸ“¦

**ä¸€å¥è¯ï¼š** Option æ˜¯"æœ‰æˆ–æ²¡æœ‰"çš„ç›’å­ï¼Œæ‰“å¼€å‰è¦æ£€æŸ¥æ˜¯ä¸æ˜¯ç©ºçš„

```rust
// Option å°±åƒä¸€ä¸ªå¯èƒ½æ˜¯ç©ºçš„ç›’å­
// Some(ä¸œè¥¿) = ç›’å­é‡Œæœ‰ä¸œè¥¿
// None = ç›’å­æ˜¯ç©ºçš„

let box1: Option<i32> = Some(42);
let box2: Option<i32> = None;

// å®‰å…¨åœ°æ£€æŸ¥
if let Some(value) = box1 {
    println!("ç›’å­é‡Œæ˜¯: {}", value);
}
```

**åº”ç”¨ï¼š** å­—ç¬¦ä¸²æŸ¥æ‰¾ `str.find("pattern")` è¿”å› `Option<usize>`

---

### å¡ç‰‡3ï¼š? æ“ä½œç¬¦ â“

**ä¸€å¥è¯ï¼š** ? æ˜¯é”™è¯¯ä¼ æ’­å¿«æ·æ–¹å¼â€”â€”é‡åˆ° Err ç«‹å³è¿”å›ï¼Œé‡åˆ° Ok è§£åŒ…ç»§ç»­

```rust
// æ²¡æœ‰ ?ï¼šç¹ç
let file = match File::open("a.txt") {
    Ok(f) => f,
    Err(e) => return Err(e),
};

// æœ‰ ?ï¼šç®€æ´
let file = File::open("a.txt")?;

// ? çš„å«ä¹‰ï¼š
// 1. å¦‚æœæ˜¯ Ok(v)ï¼Œè§£åŒ…å¾—åˆ° v
// 2. å¦‚æœæ˜¯ Err(e)ï¼Œç«‹å³ return Err(e.into())
```

**åº”ç”¨ï¼š** ripgrep å…¨ä»£ç åº“ç”¨ ? é“¾å¼ä¼ æ’­é”™è¯¯

---

### å¡ç‰‡4ï¼šunwrap çš„å±é™© ğŸ’¥

**ä¸€å¥è¯ï¼š** unwrap æ˜¯"æˆ‘ç¡®ä¿¡ä¸ä¼šå¤±è´¥"çš„æ–­è¨€ï¼Œé”™äº†å°±å´©æºƒ

```rust
// unwrap = å¼ºè¡Œæ‹†ç›’å­
let value = Some(42).unwrap();  // âœ… 42
let value = None.unwrap();       // âŒ panic!

// å®‰å…¨æ›¿ä»£
let value = maybe.unwrap_or(0);           // é»˜è®¤å€¼
let value = maybe.unwrap_or_default();    // ç±»å‹é»˜è®¤å€¼
let value = maybe.unwrap_or_else(|| compute()); // å»¶è¿Ÿè®¡ç®—

// å”¯ä¸€å¯æ¥å—çš„ unwrap åœºæ™¯
let re = Regex::new(r"^\d+$").unwrap(); // ç¡¬ç¼–ç æ­£åˆ™ä¸å¯èƒ½å¤±è´¥
```

**åº”ç”¨ï¼š** ç”Ÿäº§ä»£ç é¿å… unwrapï¼Œç”¨ ? æˆ– unwrap_or

---

### å¡ç‰‡5ï¼šmap ä¸ and_then ğŸ”„

**ä¸€å¥è¯ï¼š** map è½¬æ¢æˆåŠŸå€¼ï¼Œand_then é“¾æ¥å¯èƒ½å¤±è´¥çš„æ“ä½œ

```rust
let x: Option<i32> = Some(2);

// mapï¼šè½¬æ¢å†…éƒ¨å€¼ï¼ˆT â†’ Uï¼‰
let doubled = x.map(|n| n * 2);  // Some(4)

// and_thenï¼šé“¾æ¥å¦ä¸€ä¸ª Optionï¼ˆT â†’ Option<U>ï¼‰
let parsed = Some("42").and_then(|s| s.parse::<i32>().ok());  // Some(42)

// åŒºåˆ«ï¼š
// map(f): Some(v) â†’ Some(f(v))
// and_then(f): Some(v) â†’ f(v)  (f è¿”å› Option)
```

**åº”ç”¨ï¼š** é“¾å¼å¤„ç†é…ç½®å€¼ã€åµŒå¥— Option

---

### å¡ç‰‡6ï¼šè‡ªå®šä¹‰é”™è¯¯ç±»å‹ ğŸ”§

**ä¸€å¥è¯ï¼š** å®šä¹‰é”™è¯¯æšä¸¾ï¼Œå®ç° From trait æ”¯æŒ ? è‡ªåŠ¨è½¬æ¢

```rust
#[derive(Debug)]
enum MyError {
    Io(std::io::Error),
    Parse(std::num::ParseIntError),
    Custom(String),
}

// å®ç° Fromï¼Œè®© ? èƒ½è‡ªåŠ¨è½¬æ¢
impl From<std::io::Error> for MyError {
    fn from(e: std::io::Error) -> Self {
        MyError::Io(e)
    }
}

// ç°åœ¨å¯ä»¥è¿™æ ·å†™
fn read_number(path: &str) -> Result<i32, MyError> {
    let content = std::fs::read_to_string(path)?;  // io::Error â†’ MyError
    let num: i32 = content.trim().parse()?;        // ParseIntError â†’ MyError
    Ok(num)
}
```

**åº”ç”¨ï¼š** ripgrep å„ crate å®šä¹‰è‡ªå·±çš„é”™è¯¯ç±»å‹

---

### å¡ç‰‡7ï¼šError trait ğŸ“š

**ä¸€å¥è¯ï¼š** Error trait æ˜¯æ ‡å‡†é”™è¯¯æ¥å£ï¼Œè¦æ±‚å®ç° Debug + Display

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError(String);

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Error for MyError {}  // ç°åœ¨å¯ä»¥ç”¨ Box<dyn Error>

// Error trait çš„æ ¸å¿ƒæ–¹æ³•
trait Error: Debug + Display {
    fn source(&self) -> Option<&(dyn Error + 'static)> { None }
}
```

**åº”ç”¨ï¼š** å®ç° Error æ‰èƒ½ç”¨ `Box<dyn Error>` å’Œé”™è¯¯é“¾

---

### å¡ç‰‡8ï¼šthiserror ç”¨æ³• ğŸ› ï¸

**ä¸€å¥è¯ï¼š** thiserror é€šè¿‡æ´¾ç”Ÿå®è‡ªåŠ¨å®ç° Error trait å’Œ From è½¬æ¢

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum SearchError {
    #[error("IO é”™è¯¯: {0}")]
    Io(#[from] std::io::Error),  // è‡ªåŠ¨å®ç° From

    #[error("æ— æ•ˆçš„æ¨¡å¼: {0}")]
    InvalidPattern(String),

    #[error("æ–‡ä»¶æœªæ‰¾åˆ°: {path}")]
    NotFound { path: String },
}

// è‡ªåŠ¨ç”Ÿæˆï¼š
// - Display å®ç°ï¼ˆ#[error(...)]ï¼‰
// - From å®ç°ï¼ˆ#[from]ï¼‰
// - Error trait å®ç°
```

**åº”ç”¨ï¼š** åº“å¼€å‘é¦–é€‰ï¼Œä¿ç•™ç±»å‹ä¿¡æ¯ä¾¿äºæ¨¡å¼åŒ¹é…

---

### å¡ç‰‡9ï¼šanyhow ç”¨æ³• ğŸ’

**ä¸€å¥è¯ï¼š** anyhow æä¾›é€šç”¨ Error ç±»å‹å’Œ context() æ–¹æ³•ï¼Œé€‚åˆåº”ç”¨å¼€å‘

```rust
use anyhow::{Context, Result, bail};

fn read_config(path: &str) -> Result<Config> {
    let content = std::fs::read_to_string(path)
        .context("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥")?;  // æ·»åŠ ä¸Šä¸‹æ–‡

    let config: Config = toml::from_str(&content)
        .context("è§£æ TOML å¤±è´¥")?;

    if config.threads == 0 {
        bail!("çº¿ç¨‹æ•°ä¸èƒ½ä¸º 0");  // å¿«é€Ÿè¿”å›é”™è¯¯
    }

    Ok(config)
}

// é”™è¯¯é“¾è¾“å‡ºï¼š
// Error: è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥
// Caused by:
//     No such file or directory (os error 2)
```

**åº”ç”¨ï¼š** åº”ç”¨ç¨‹åºå¼€å‘é¦–é€‰ï¼Œå¿«é€ŸåŸå‹

---

### å¡ç‰‡10ï¼šripgrep é”™è¯¯å¤„ç†æ¨¡å¼ ğŸ”

**ä¸€å¥è¯ï¼š** å„ crate å®šä¹‰é”™è¯¯ç±»å‹ï¼Œ? å±‚å±‚ä¼ æ’­ï¼Œmain ç»Ÿä¸€æ ¼å¼åŒ–ç»™ç”¨æˆ·

```rust
// grep-regex crate
enum RegexError { Syntax(...), ... }

// grep-searcher crate
enum SearchError { Io(...), Regex(RegexError), ... }

// ignore crate
enum IgnoreError { Io(...), Glob(...), ... }

// main.rs ç»Ÿä¸€å¤„ç†
fn main() {
    if let Err(e) = run() {
        eprintln!("error: {}", e);

        // æ‰“å°é”™è¯¯é“¾
        let mut source = e.source();
        while let Some(s) = source {
            eprintln!("caused by: {}", s);
            source = s.source();
        }

        std::process::exit(1);
    }
}
```

**åº”ç”¨ï¼š** ç”¨æˆ·çœ‹åˆ°å‹å¥½é”™è¯¯ä¿¡æ¯è€Œéå †æ ˆè·Ÿè¸ª

---

## ã€ä¸€å¥è¯æ€»ç»“ã€‘

**é”™è¯¯å¤„ç†æ˜¯ Rust é€šè¿‡ Result<T, E> å’Œ Option<T> åœ¨ç±»å‹ç³»ç»Ÿä¸­å®ç°çš„ç¼–è¯‘æ—¶å¼ºåˆ¶æœºåˆ¶ï¼Œ? æ“ä½œç¬¦è®©é”™è¯¯ä¼ æ’­æ˜¾å¼å¯è§ä¸”é›¶æˆæœ¬ï¼Œripgrep ä¾æ­¤ä¼˜é›…å¤„ç†æ–‡ä»¶ IOã€æ­£åˆ™ç¼–è¯‘ã€å‘½ä»¤è¡Œè§£æç­‰å„ç§å¯èƒ½å¤±è´¥çš„æ“ä½œï¼Œå°†å†…éƒ¨é”™è¯¯è½¬åŒ–ä¸ºç”¨æˆ·å‹å¥½çš„æç¤ºä¿¡æ¯ã€‚**

---

## å­¦ä¹ æ£€æŸ¥æ¸…å•

### æ¦‚å¿µç†è§£
- [ ] ç†è§£ Result<T, E> çš„ä¸¤ä¸ªå˜ä½“ Ok/Err
- [ ] ç†è§£ Option<T> çš„ä¸¤ä¸ªå˜ä½“ Some/None
- [ ] ç†è§£ Result å’Œ Option çš„åŒºåˆ«ï¼ˆæœ‰æ— é”™è¯¯ä¿¡æ¯ï¼‰
- [ ] ç†è§£ ? æ“ä½œç¬¦çš„å·¥ä½œåŸç†
- [ ] ç†è§£ panic! å’Œ Result çš„ä½¿ç”¨åœºæ™¯åŒºåˆ«
- [ ] ç†è§£ä¸ºä»€ä¹ˆ Rust ä¸ç”¨å¼‚å¸¸

### å®è·µèƒ½åŠ›
- [ ] èƒ½å†™è¿”å› Result çš„å‡½æ•°
- [ ] èƒ½ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
- [ ] èƒ½ç”¨ map/and_then é“¾å¼å¤„ç† Option
- [ ] èƒ½ç”¨ unwrap_or/unwrap_or_else æä¾›é»˜è®¤å€¼
- [ ] èƒ½å®šä¹‰ç®€å•çš„è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- [ ] èƒ½å®ç° From trait æ”¯æŒ ? è½¬æ¢

### è¿›é˜¶ç†è§£
- [ ] äº†è§£ thiserror crate çš„ç”¨æ³•
- [ ] äº†è§£ anyhow crate çš„ç”¨æ³•
- [ ] ç†è§£ä½•æ—¶ç”¨ thiserror vs anyhow
- [ ] ç†è§£é”™è¯¯é“¾ï¼ˆError::sourceï¼‰

---

## ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

1. **å®è·µç»ƒä¹ **ï¼šå†™ä¸€ä¸ªè¯»å–é…ç½®æ–‡ä»¶çš„å‡½æ•°ï¼Œå¤„ç†æ–‡ä»¶ä¸å­˜åœ¨ã€è§£æå¤±è´¥ç­‰æƒ…å†µ
2. **é˜…è¯» ripgrep æºç **ï¼šçœ‹ `grep-searcher/src/searcher/mod.rs` ä¸­çš„é”™è¯¯å¤„ç†
3. **å­¦ä¹  thiserror**ï¼š[thiserror æ–‡æ¡£](https://docs.rs/thiserror)
4. **å­¦ä¹  anyhow**ï¼š[anyhow æ–‡æ¡£](https://docs.rs/anyhow)
5. **ç›¸å…³çŸ¥è¯†ç‚¹**ï¼š
   - è¿­ä»£å™¨ä¸é—­åŒ…ï¼ˆmap/filter/and_then çš„åŸºç¡€ï¼‰
   - æ¨¡å¼åŒ¹é…ï¼ˆmatch/if let çš„æ·±å…¥ï¼‰
   - traitï¼ˆError trait çš„ç†è§£ï¼‰

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2025-01
**å…³è” ripgrep ç‰ˆæœ¬ï¼š** 14.x
